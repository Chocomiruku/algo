package sorts.count;

import static sorts.Utils.getMaxValue;
import static sorts.Utils.printArray;

public class CountSort {

    /**
     * Метод, который реализует сортировку подсчётом.
     * Сложность O(n + k) - линейная, где n - количество элементов, k - диапазон значений.
     */
    public static int[] countingSort(int[] array) {
        // Находим максимальный элемент массива, чтобы определить размер массива подсчёта
        int maxElement = getMaxValue(array);

        // Инициализируем массив подсчёта
        int[] countArray = new int[maxElement + 1];

        // Подсчитываем количество каждого элемента в исходном массиве
        for (int i = 0; i < array.length; i++) {
            countArray[array[i]]++;
        }

        // Инициализируем индекс для перебора массива подсчёта
        int index = 0;

        for (int i = 0; i < countArray.length; i++) {
            // Копируем элемент в исходный массив столько раз, сколько он встречается
            for (int j = 0; j < countArray[i]; j++) {
                array[index++] = i;
            }
        }

        return array;
    }

    public static void main(String[] args) {
        int[] array = {12, 11, 13, 5, 6, 7};

        System.out.println("Данный массив");
        printArray(array);

        countingSort(array);

        System.out.println("\nОтсортированный массив");
        printArray(array);
    }
}

//    Главная идея алгоритма — посчитать, сколько раз встречается каждый элемент в массиве, а потом
//    заполнить исходный массив результатами этого подсчёта. Для этого нам нужен вспомогательный массив,
//    где мы будем хранить результаты подсчёта. Даже если нам надо отсортировать миллион чисел,
//    мы всё равно знаем диапазон этих чисел заранее, например, от 1 до 100. Это значит, что во
//    вспомогательном массиве будет не миллион элементов, а сто.
//
//        В общем виде всё работает так:
//
//        1. Мы создаём вспомогательный массив и на старте заполняем его нулями.
//        2. Проходим по всему исходному массиву и смотрим очередное значение в ячейке.
//        3. Берём содержимое этой ячейки и увеличиваем на единицу значение вспомогательного
//           массива под этим номером. Например, если мы встретили число 5, то увеличиваем на единицу
//           пятый элемент вспомогательного массива.
//        4. После цикла во вспомогательном массиве у нас хранятся данные, сколько раз встречается
//           каждый элемент.
//        5. Теперь мы проходим по вспомогательному массиву, и если в очередной ячейке лежит
//           что-то больше нуля, то мы в исходный массив столько же раз отправляем номер этой ячейки.
//           Например, в первой ячейке вспомогательного массива лежит число 7.
//           Это значит, что в исходный массив мы отправляем единицу 7 раз подряд.
